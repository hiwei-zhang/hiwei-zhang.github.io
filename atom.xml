<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hiwei-zhang.github.io</id>
    <title>Hiwei</title>
    <updated>2021-03-31T13:44:56.809Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hiwei-zhang.github.io"/>
    <link rel="self" href="https://hiwei-zhang.github.io/atom.xml"/>
    <subtitle>不积硅步，无以至千里</subtitle>
    <logo>https://hiwei-zhang.github.io/images/avatar.png</logo>
    <icon>https://hiwei-zhang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Hiwei</rights>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://hiwei-zhang.github.io/post/dai-li-mo-shi/</id>
        <link href="https://hiwei-zhang.github.io/post/dai-li-mo-shi/">
        </link>
        <updated>2021-03-27T10:55:42.000Z</updated>
        <summary type="html"><![CDATA[<p>代理模式详解及demo</p>
]]></summary>
        <content type="html"><![CDATA[<p>代理模式详解及demo</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://hiwei-zhang.github.io/post/dan-li-mo-shi/</id>
        <link href="https://hiwei-zhang.github.io/post/dan-li-mo-shi/">
        </link>
        <updated>2021-03-27T10:47:48.000Z</updated>
        <summary type="html"><![CDATA[<p>一文带你掌握单例模式！</p>
]]></summary>
        <content type="html"><![CDATA[<p>一文带你掌握单例模式！</p>
<!-- more -->
<h1 id="单例模式应用场景">单例模式应用场景</h1>
<p>单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。单例模式是创建型模式。在Spring框架中ApplicationContext就是单例模式的应用。</p>
<h1 id="饿汉式单例">饿汉式单例</h1>
<p>饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。线程安全。<br>
优点：没有加任何的锁、执行效率比较高。<br>
缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。</p>
<pre><code class="language-java">public class HungrySingleton {
    private static final HungrySingleton INSTANCE = new HungrySingleton();

    private HungrySingleton(){}

    public static final HungrySingleton getINSTANCE(){
        return INSTANCE;
    }
}
</code></pre>
<p>还有另一种写法，利用静态代码块的方式：</p>
<pre><code class="language-java">public class HungrySingleton {
    private static final HungrySingleton INSTANCE;
    static {
        INSTANCE = new HungrySingleton();
    }
    private HungrySingleton(){}
    public static final HungrySingleton getINSTANCE(){
        return INSTANCE;
    }
}
</code></pre>
<p>以上写法都非常简单，饿汉式单例适用于在单例对象较少的情况下。</p>
<h1 id="懒汉式">懒汉式</h1>
<p>懒汉式单例的特点是：被外部类调用的时候内才会创建实例。</p>
<ol>
<li>非线程安全</li>
</ol>
<pre><code class="language-java">//懒汉式单例 //在外部需要使用的时候才进行实例化 
public class LazySimpleSingleton { 
    private LazySimpleSingleton(){} 
    //静态块，公共内存区域 
    private static LazySimpleSingleton lazy = null; 
    public static LazySimpleSingleton getInstance(){ 
        if(lazy == null){ 
            lazy = new LazySimpleSingleton(); 
        }
        return lazy; 
} 
</code></pre>
<p>以上写法在多线程调用的情况下会出现线程安全问题，有一定几率创建多个实例。<br>
所以我们可以对以上代码进行修改，就是上锁：<br>
2. 方法加锁</p>
<pre><code class="language-java">public class LazySimpleSingleton { 
    private LazySimpleSingleton(){} 
    //静态块，公共内存区域 
    private static LazySimpleSingleton lazy = null; 
    public  synchronized static LazySimpleSingleton getInstance(){ 
        if(lazy == null){ 
            lazy = new LazySimpleSingleton(); 
        }
        return lazy; 
} 
</code></pre>
<p>此种加锁方式在多线程情况下会导致线程阻塞，程序运行性能大幅下降。所以我们可以进一步升级：<br>
3. 双重校验锁</p>
<pre><code class="language-java">public class LazyDoubleCheckSingleton {
    private volatile static LazyDoubleCheckSingleton lazy;
    private LazyDoubleCheckSingleton() {
    }
    public static LazyDoubleCheckSingleton getInstance() {
        if (lazy == null) {
            synchronized (LazyDoubleCheckSingleton.class) {
                if (lazy == null) {
                    lazy = new LazyDoubleCheckSingleton();
                }
            }
        }
        return lazy;
    }
} 
</code></pre>
<p>此种方法采用了双重校验锁的方式，在实例创建完成后，多线程调用的情况下也不会阻塞线程。但是此种方式在多线程都来初始化实例的时候就会形成锁竞争，也会对性能造成影响。<br>
我们可以采用一种更为优雅的写法：<br>
4. 静态内部类</p>
<pre><code class="language-java">public class StaticInnerClassHurrySingleton {
    private StaticInnerClassHurrySingleton(){}
    public static final StaticInnerClassHurrySingleton getINSTANCE(){
        return Holder.SINGLETON;
    }
    private static class Holder{
        private static final StaticInnerClassHurrySingleton SINGLETON = new StaticInnerClassHurrySingleton();
    }
}
</code></pre>
<p>静态内部类的写法既没有饿汉式的内存浪费问题，也没有加锁带来的性能开销。内部类一定是在方法调用之前初始化的，巧妙的避免了线程安全问题。</p>
<h1 id="单例模式的破坏">单例模式的破坏</h1>
<h2 id="反射破坏单例">反射破坏单例</h2>
<p>大家有没有发现，上面介绍的单例模式的构造方法除了加上private以外，没有做任何处理。如果我们使用反射来调用其构造方法，然后，再调用getInstance()方法，就可以创建两个不同的实例。现在来看一段测试代码，以StaticInnerClassHurrySingleton为例：</p>
<pre><code class="language-java">public class StaticInnerClassHurrySingletonTest {
    public static void main(String[] args) {
        try {
            //很无聊的情况下，进行破坏
            Class&lt;?&gt; clazz = StaticInnerClassHurrySingleton.class;
            //通过反射拿到私有的构造方法
            Constructor c = clazz.getDeclaredConstructor(null);
            //强制访问
            c.setAccessible(true);
            //暴力初始化
            Object o1 = c.newInstance();
            //调用了两次构造方法，相当于 new了两次
            Object o2 = c.newInstance();
            System.out.println(o1 == o2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行结果：false<br>
显然创建了两个不同的实例，我们可以在构造方法中添加现在来，一旦出现多次创建，则直接抛出异常：</p>
<pre><code class="language-java">public class StaticInnerClassHurrySingleton {
    private StaticInnerClassHurrySingleton(){
        //添加实例检查
        if(Holder.SINGLETON!=null){
            //抛出异常
            throw new RuntimeException(&quot;实例已被创建&quot;);
        }
    }
    public static final StaticInnerClassHurrySingleton getINSTANCE(){
        return Holder.SINGLETON;
    }
    private static class Holder{
        private static final StaticInnerClassHurrySingleton SINGLETON = new                   StaticInnerClassHurrySingleton();
    }
}
</code></pre>
<p>继续上面的测试，结果:</p>
<pre><code class="language-java">java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at com.hiwei.pattern.singleton.hunger.LazyInnerClassSingletonTest.main(LazyInnerClassSingletonTest.java:19)
Caused by: java.lang.RuntimeException: 实例已被创建
	at com.hiwei.pattern.singleton.hunger.StaticInnerClassHurrySingleton.&lt;init&gt;(StaticInnerClassHurrySingleton.java:10)
	... 5 more
</code></pre>
<p>反射破坏单例漏洞就被修复掉了。</p>
<h2 id="序列化破坏单例">序列化破坏单例</h2>
<p>当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例，来看一段代码：</p>
<pre><code class="language-java">public class SeriableSingleton implements Serializable {
    /*
    序列化：
    把内存中的状态通过转换成字节码的形式
    从而转换一个 IO 流，写入到其他地方(可以是磁盘、网络 IO)
    内存中状态给永久保存下来了
    反序列化：
    将已经持久化的字节码内容，转换为 IO 流 //通过 IO 流的读取，进而将读取的内容转换为 Java 对象
    在转换过程中会重新创建对象new
    */
    public final static SeriableSingleton INSTANCE = new SeriableSingleton();
    private SeriableSingleton() {
    }
    public static SeriableSingleton getInstance() {
        return INSTANCE;
    }
}
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java">public class SeriableSingletonTest {
    public static void main(String[] args) {
        SeriableSingleton s1 = null;
        SeriableSingleton s2 = SeriableSingleton.getInstance();
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;SeriableSingleton.obj&quot;);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s2);
            oos.flush();
            oos.close();
            FileInputStream fis = new FileInputStream(&quot;SeriableSingleton.obj&quot;);
            ObjectInputStream ois = new ObjectInputStream(fis);
            s1 = (SeriableSingleton) ois.readObject();
            ois.close();
            System.out.println(s1);
            System.out.println(s2);
            System.out.println(s1 == s2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-java">com.hiwei.pattern.singleton.hunger.SeriableSingleton@6acbcfc0
com.hiwei.pattern.singleton.hunger.SeriableSingleton@60e53b93
false
</code></pre>
<p>结果表明单例模式已经被序列化破坏掉了。怎么避免呢？<br>
增加readResolve()方法即可。来看优化代码：</p>
<pre><code class="language-java">/**
 * @author: hiwei
 * @create: 2018-06-25 22:24
 */
public class SeriableSingleton implements Serializable {

    public final static SeriableSingleton INSTANCE = new SeriableSingleton();
    private SeriableSingleton() {
    }
    public static SeriableSingleton getInstance() {
        return INSTANCE;
    }
    private Object readResolve(){ return INSTANCE; }
}
</code></pre>
<p>仍由上面测试方法测试，测试结果：</p>
<pre><code class="language-java">com.hiwei.pattern.singleton.hunger.SeriableSingleton@60e53b93
com.hiwei.pattern.singleton.hunger.SeriableSingleton@60e53b93
true
</code></pre>
<p>显然问题被解决了。<br>
为什么加一个方法就解决了这个问题？我们可以看下JDK的源码，就是ObjectInputStream类的readObject()方法，通过这个方法我们可以看到以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。这部分代码因为篇幅较多，就不在此解析了。那如果，创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大。下面我们可以采用另一种方式来实现单例：</p>
<h1 id="注册式单例">注册式单例</h1>
<p>。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。</p>
<h2 id="枚举式单例">枚举式单例</h2>
<p>枚举式单例的写法，来看代码，创建EnumSingleton类：</p>
<pre><code class="language-java">public enum EnumSingleton { 
    INSTANCE; 
    private Object data; 
    public Object getData() { 
        return data; 
    } 
    public void setData(Object data) { 
        this.data = data;
    } 
    public static EnumSingleton getInstance(){ 
        return INSTANCE; 
    } 
}
</code></pre>
<p>使用反编译工具来反编译该类，可以得到以下代码：</p>
<pre><code class="language-java">static {
        INSTANCE = new EnumSingleton(&quot;INSTANCE&quot;, 0);
        $VALUES = (new EnumSingleton[]{INSTANCE});
    }
</code></pre>
<p>枚举式单例在静态代码块中就给INSTANCE进行了赋值，是饿汉式单例的实现。</p>
<h2 id="容器式单例">容器式单例</h2>
<pre><code class="language-java">public class ContainerSingleton {
    private ContainerSingleton(){}
    private static Map&lt;String,Object&gt; ioc = new ConcurrentHashMap&lt;String,Object&gt;();
    public static Object getInstance(String className){
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object obj = null;
                try {
                    obj = Class.forName(className).newInstance();
                    ioc.put(className, obj);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return obj;
            } else {
                return ioc.get(className);
            }
        }
    }
}
</code></pre>
<p>spring的IOC容器使用的就是这种单例模式。</p>
<h2 id="threadlocal线程单例">ThreadLocal线程单例</h2>
<p>线程单例实现 ThreadLocal。ThreadLocal 不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，线程安全。</p>
<pre><code class="language-java">public class ThreadLocalSingleton {
    private static final ThreadLocal&lt;ThreadLocalSingleton&gt; threadLocalInstance =
            new ThreadLocal&lt;ThreadLocalSingleton&gt;(){
                @Override
                protected ThreadLocalSingleton initialValue() {
                    return new ThreadLocalSingleton();
                }
            };

    private ThreadLocalSingleton(){}

    public static ThreadLocalSingleton getInstance(){
        return threadLocalInstance.get();
    }
}
</code></pre>
<h1 id="总结">总结</h1>
<p>自此单例模式都实现了。单例模式保证了类内存里面只有一个内存实例，减少了内存开销，避免了对内存资源的多重占用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务概述]]></title>
        <id>https://hiwei-zhang.github.io/post/wei-fu-wu-gai-shu/</id>
        <link href="https://hiwei-zhang.github.io/post/wei-fu-wu-gai-shu/">
        </link>
        <updated>2021-03-27T03:38:39.000Z</updated>
        <summary type="html"><![CDATA[<p>微服务架构相关概念。</p>
]]></summary>
        <content type="html"><![CDATA[<p>微服务架构相关概念。</p>
<!-- more -->
<h1 id="架构的演变">架构的演变</h1>
<h2 id="单体架构">单体架构</h2>
<ol>
<li>什么是单体架构？<br>
一个程序包（war/jar）包含了应用所有功能的应用程序。这样的架构方法论，称之为单体架构。</li>
<li>单体架构示意图<br>
<img src="https://hiwei-zhang.github.io/post-images/1616817865142.jpg" alt="" width="400" height="400" loading="lazy"></li>
<li>单体架构缺陷</li>
</ol>
<ul>
<li>复杂性高。整个项目包含的模块都耦合在一起，模块的边界模糊，依赖关系不清晰。当业务过于复杂和模块过多的时候，整个项目变得异常复杂，每次修改代码都心惊胆战，甚至修改一个bug会产生多个隐藏bug。</li>
<li>会产生技术债务。随着时间的推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。已使用的系统设计或代码难以修改，因为整个应用程序间的模块调用链路不清晰，随意修改可能会产生意想不到错误。</li>
<li>扩展能力受限。单体应用只能作为一个整体扩展，各模块无法结合自身业务体量进行伸缩部署。</li>
<li>阻碍技术创新。单体应用往往使用统一的技术框架和方案解决所有问题，团队的每个开发成员都必须使用相同的语言和架构，要想引入新的框架和技术非常难。<br>
  由于单体架构的缺陷在业务体量日益增长的情况下越来越突出，所以越来越多的公司采用微服务架构解决上述问题。</li>
</ul>
<h2 id="集群架构">集群架构</h2>
<p>  在用户量不断增加的时候，单体架构下服务器的压力越来越大，所以可能导致整个系统的性能达不到要求，这时就需要提升系统承受能力。可以提升服务器硬件性能达到目的，但是这样并不划算。所以集群架构就出现了。<br>
<img src="https://hiwei-zhang.github.io/post-images/1616840919922.png" alt="" loading="lazy"></p>
<h2 id="soa架构">SOA架构</h2>
<p>  虽然集群架构可以提升并行处理能力和达到系统高可用的目的，但是把所有的业务都放到一个war中来管理，对于代码的维护和扩展时非常困难的。而且如果某个业务功能出现故障的时候，可能导致整个系统都不可用。所以这个时候就是要降低业务之间的耦合度，提升系统的容错性。这时就可以以业务的维度对系统进行垂直拆分。简单来说，就是根据业务将系统拆分为多个模块。例如电商网站，会拆分为：首页、订单、支付、商品、搜索等多个模块。我之前做过的国家电网的综合能源项目就拆分为：全景大厅、运行监测、运维管理、人员管理、设备管理、告警管理等子系统。每个子系统交由一个小开发团队负责。<br>
<img src="https://hiwei-zhang.github.io/post-images/1616841006671.png" alt="" width="400" height="400" loading="lazy"><br>
  随着对业务系统进行垂直化改造之后，以业务功能纬度拆分出来多个子系统，而在各个子系 统中，会存在比较多的共享业务，比如用户信息查询，在支付业务中会涉及到、在首页中也 会涉及到。那么势必会造成重复开发产生非常多的冗余代码。那么这个时候就引入了服务化 改造的思想，也就是SOA把一些通用的、会被多个上层服务调用的模块独立拆分出来，形成一些共享的基础服务。这 些被拆分出来的共享服务相对来说是比较独立，并且可重用。 比如用户管理服务，包含用户 注册、用户查询等功能。比如单点登录服务； SOA的核心目标就是通过服务的流程化来实现业务的灵活性，而这个流程化其实就是一系列 相关联的任务组成，这一系列相关联的任务可以通过一系列的服务组合来实现具体的业务功 能 SOA面向服务架构，从语义上说，它与面向过程、面向对象、面向组件一样，是一种软件组 建及开发的方式。所以在SOA中，服务是最核心的抽象手段，业务被划分为一些列粗粒度的业务服务和业务流程 。<br>
  SOA中更强调ESB企业服务总线，企业服务总线可以使得服务之间的交互是动态的，以及服 务位置是透明的。这样的好处是服务的调用者和服务的提供者之间是高度解耦的。从而使得 服务有更高的灵活性以及隔离性。<br>
ESB： 是从面相服务架构(SOA)发展过来的，主要是对多个系统中的服务调用者和服务提供 者的解耦。ESB本身提供了服务暴露、接入、协议转化、数据格式转化、路由等功能。   SOA主要解决的问题：</p>
<ol>
<li>信息孤岛</li>
<li>互联互通</li>
<li>业务重用</li>
</ol>
<h2 id="微服务架构">微服务架构</h2>
<p>  微服务并不是一种新思想的方法。它更像是一种思想的精炼，是一种服务化思想的最佳实践 方向而已，所以我认为微服务其实是在SOA思路下，随着各个企业对于服务化治理上不断的 完善，以及对软件的交付链路以及基础设施逐步成熟之下的一种自然的产物。 微服务也是一 种面向服务的架构模型，只是它更强调服务的粒度。也就是服务的职责更加单一更加精炼 我们也可以把SOA看成是微服务的超集。 也就是多个微服务可以组成一个soa服务。</p>
<ul>
<li>SOA与微服务区别：</li>
</ul>
<ol>
<li>SOA关注的是服务的重用性，和解决企业服务信息孤岛的问题。</li>
<li>微服务关注的是解耦。微服务关注降低业务之间的耦合度（服务粒度），而可重用性关注的是服务的复用。</li>
<li>微服务会使用更轻量级的通信协议，使用Restful风格的API。轻量级协议可以很好的支持 跨语言，是的语言生态更加丰富。</li>
<li>微服务会更多的关注Devops的持续交付，因为服务粒度更细使得开发运维变得更加重要。 所以微服务对于容器化技术的结合更加紧密。</li>
<li>SOA应该是微服务的超集。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring集成websocket]]></title>
        <id>https://hiwei-zhang.github.io/post/spring-ji-cheng-websocket/</id>
        <link href="https://hiwei-zhang.github.io/post/spring-ji-cheng-websocket/">
        </link>
        <updated>2021-03-25T14:04:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="maven依赖">maven依赖</h1>
<!-- websocket -->
<pre><code>        &lt;dependency&gt;
              &lt;groupId&gt;org.springframework&lt;/groupId&gt;
              &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;
              &lt;version&gt;4.0.3.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;org.springframework&lt;/groupId&gt;
              &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;
              &lt;version&gt;4.3.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
              &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
              &lt;version&gt;1.0&lt;/version&gt;
              &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;org.eclipse.jetty.websocket&lt;/groupId&gt;
              &lt;artifactId&gt;websocket-server&lt;/artifactId&gt;
              &lt;version&gt;9.3.3.v20150827&lt;/version&gt;
              &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
              &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
              &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;
              &lt;version&gt;8.0.23&lt;/version&gt;
              &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h1 id="配置入口类">配置入口类</h1>
<p>配置WebSocket的入口,编写WebSocketConfig类实现WebSocketConfigurer 接口</p>
<pre><code class="language-java">package com.hiwei.demo.webSocket;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.handler.TextWebSocketHandler;
@Configuration
@EnableWebSocket
@EnableWebMvc
public class SpringWebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(webSocketHandler(),&quot;/websocket/socketServer.do&quot;).addInterceptors(new SpringWebSocketHandlerInterceptor());
        registry.addHandler(webSocketHandler(), &quot;/sockjs/socketServer.do&quot;).addInterceptors(new SpringWebSocketHandlerInterceptor()).withSockJS();      
    }
    @Bean
    public TextWebSocketHandler webSocketHandler(){
        return new SpringWebSocketHandler();
    }
}
</code></pre>
<h1 id="定义入口类">定义入口类</h1>
<p>定义一个SpringWebSocketHandler类继承TextWebSocketHandler，这个类是用来处理Websocket连接建立、断开，消息发送的逻辑的，这个是消息处理的核心代码:</p>
<pre><code class="language-java">package com.hiwei.demo.webSocket;
import java.io.IOException;
import java.util.HashMap;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;
public class SpringWebSocketHandler extends TextWebSocketHandler {
 
    private static final HashMap&lt;String,WebSocketSession&gt; users;
    static {
        users = new HashMap&lt;String,WebSocketSession&gt;();
    }
   
    public SpringWebSocketHandler() {
    }
   
    /**
     * 连接成功触发
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        users.put((String) session.getAttributes().get(&quot;SESSION_USERID&quot;), session);
        System.out.println(&quot;connect to the websocket success......当前数量:&quot;+users.size());
        //这块会实现自己业务，比如，当用户登录后，会把离线消息推送给用户
      TextMessage returnMessage = new TextMessage(&quot;连接成功&quot;);
       session.sendMessage(returnMessage);
    }
    /**
     * 关闭连接时触发
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {
        String username= (String) session.getAttributes().get(&quot;WEBSOCKET_USERNAME&quot;);
        System.out.println(&quot;用户&quot;+username+&quot;已退出！&quot;);
        users.remove(session.getAttributes().get(&quot;SESSION_USERID&quot;));
        System.out.println(&quot;剩余在线用户&quot;+users.size());
    }
    /**
     * js调用websocket.send时候，会调用该方法
     */
    @Override   
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        super.handleTextMessage(session, message);
        TextMessage returnMessage = new TextMessage(message.getPayload().toString());
        sendMessageToUsers(returnMessage);
    }
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        if(session.isOpen()){session.close();}
        users.remove(session.getAttributes().get(&quot;SESSION_USERID&quot;));
    }
    public boolean supportsPartialMessages() {
        return false;
    }
    /**
     * 给某个用户发送消息
     *
     * @param userName
     * @param message
     */
    public void sendMessageToUser(String userName, TextMessage message) {
      for (WebSocketSession user: users.values()) {
            if (user.getAttributes().get(&quot;WEBSOCKET_USERNAME&quot;).equals(userName)) {
                try {
                    if (user.isOpen()) {
                        user.sendMessage(message);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
                break;
            }
            }
    }
    /**
     * 给所有在线用户发送消息
     *
     * @param message
     */
    public void sendMessageToUsers(TextMessage message) {
        for (WebSocketSession user : users.values()) {
            try {
                if (user.isOpen()) {
                    user.sendMessage(message);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    } 
}
</code></pre>
<h1 id="拦截器配置">拦截器配置</h1>
<blockquote>
<p>从WebSocketConfig中可以看到在注册WebSocket通道时，不仅设置了入口地址，还配置了拦截器，拦截器可以实现握手之前和之后的逻辑操作，这里配置的拦截器主要用于保存用户名以便于在Handler中定向发送消息。</p>
</blockquote>
<pre><code>package com.hiwei.demo.webSocket;
import java.util.Map;
import javax.servlet.http.HttpSession;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;
public class SpringWebSocketHandlerInterceptor extends HttpSessionHandshakeInterceptor {
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,
            Map&lt;String, Object&gt; attributes) throws Exception {
        if (request instanceof ServletServerHttpRequest) {
            ServletServerHttpRequest servletRequest = (ServletServerHttpRequest) request;
            HttpSession session = servletRequest.getServletRequest().getSession(false);
            if (session != null) {
                //使用userName区分WebSocketHandler，以便定向发送消息
                String userName = (String) session.getAttribute(&quot;SESSION_USERNAME&quot;);
                if (userName==null) {
                    userName=&quot;default-system&quot;;
                }
                attributes.put(&quot;WEBSOCKET_USERNAME&quot;,userName);
            }
        }
        return super.beforeHandshake(request, response, wsHandler, attributes);
    }
    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler,
            Exception ex) {
        super.afterHandshake(request, response, wsHandler, ex);
    }
}
</code></pre>
<h1 id="配置websocket连接前台页面">配置Websocket连接前台页面</h1>
<p>网页端连接Websocket和推送消息的界面就是这里</p>
<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;
    pageEncoding=&quot;utf-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;消息&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/jquery/3.1.0/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var msgDiv = document.getElementById(&quot;#msgDiv&quot;);
    var websocket = null;
    if ('WebSocket' in window) {
        websocket = new WebSocket(&quot;ws://172.30.99.37:8080/springmvcMybatis/websocket/socketServer.do&quot;);
    }
    else if ('MozWebSocket' in window) {
        websocket = new MozWebSocket(&quot;ws://172.30.99.37:8080/springmvcMybatis/websocket/socketServer.do&quot;);
    }
    else {
        websocket = new SockJS(&quot;http://172.30.99.37:8080/springmvcMybatis/sockjs/socketServer.do&quot;);
    }
    websocket.onopen = onOpen;     
    websocket.onmessage = onMessage;
    websocket.onerror = onError;
    websocket.onclose = onClose;
    function onOpen(openEvt) {
        //alert(openEvt.Data+&quot;onOpen&quot;);
    }
    function onMessage(evt) {
            $('#msgDiv').val(evt.data)
       
            
    }
    function onError() {
        alert(&quot;出错&quot;+&quot;onError&quot;);
    }
    function onClose() {
        alert(&quot;关闭&quot;+&quot;onClose&quot;);
    }
    function doSend() {
        if (websocket.readyState == websocket.OPEN) {         
            var msg = document.getElementById(&quot;inputMsg&quot;).value; 
            websocket.send(msg);
        } else { 
            alert(&quot;连接失败!&quot;); 
        } 
    }
    window.close=function(){
        websocket.onclose();
    }
&lt;/script&gt;
&lt;body align=&quot;center&quot;&gt;
    &lt;h3&gt;消息推送&lt;/h3&gt;
    请输入：&lt;textarea rows=&quot;8&quot; cols=&quot;50&quot; id=&quot;inputMsg&quot; name=&quot;inputMsg&quot;&gt;&lt;/textarea&gt;
    &lt;button onclick=&quot;doSend();&quot;&gt;发送&lt;/button&gt;
    &lt;hr/&gt;
    &lt;textarea rows=&quot;10&quot; cols=&quot;70&quot; id=&quot;msgDiv&quot;&gt;&lt;/textarea&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>另：web.xml中的servlet和filter中添加异步支持</p>
<pre><code class="language-html">&lt;async-supported&gt;true&lt;/async-supported&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql索引]]></title>
        <id>https://hiwei-zhang.github.io/post/mysql-suo-yin/</id>
        <link href="https://hiwei-zhang.github.io/post/mysql-suo-yin/">
        </link>
        <updated>2021-03-24T14:07:19.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="索引">索引</h2>
<h4 id="索引是谁实现的">索引是谁实现的？</h4>
<p>  索引是第三方存储引擎实现的。</p>
<h4 id="索引是什么">索引是什么？</h4>
<p>  索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构。</p>
<h4 id="为什么要用索引">为什么要用索引？</h4>
<ol>
<li>索引能极大的减少存储引擎需要扫描的数据量。</li>
<li><strong>索引可以把随机IO变成顺序IO</strong></li>
<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表。<br>
总之：索引能提升数据查找速度。</li>
</ol>
<h3 id="二叉树">二叉树</h3>
<h4 id="二叉查找树binary-search-tree">二叉查找树（Binary Search Tree）</h4>
<p>  又称二叉排序树（Binary Sort Tree）<br>
该树的右子节点总是大于父节点，左子节点总是小于父节点。缺点：当一系列数据呈递增或递减插入时，二叉搜索树则变为链表形式，性能下降。<br>
<img src="en-resource://database/860:1" alt="4385f386e3d14eadddd9f35f9f4c8c41.png" loading="lazy">@w=200<img src="en-resource://database/862:1" alt="eae4f407986857c413e631c9812af866.png" loading="lazy">@w=200</p>
<h4 id="平衡二叉查找树balanced-binary-tree">平衡二叉查找树（Balanced Binary Tree）</h4>
<p><img src="en-resource://database/870:1" alt="40c123c425cacaaf3e98eca6b55df399.png" loading="lazy">@w=500<br>
平衡二叉树在二叉查找树的基础上添加了LR操作，使得<strong>二叉树子节点的高度差不大于1</strong>。解决了二叉查找树线性问题。<br>
<img src="en-resource://database/868:1" alt="bf194db5036f588f4510979888971f2b.png" loading="lazy">@w=500<br>
常见平衡二叉树：</p>
<ul>
<li>红黑树</li>
<li>AVL树</li>
</ul>
<p>平衡二叉树缺点：</p>
<ol>
<li>树太深了<br>
数据所处的深度决定查找它所需的io次数，深度越深，io耗时越久。</li>
<li>太小了<br>
  每一个磁盘块（节点/页）保存的数据量太小了，没有很好的利用操作磁盘IO的数据交换特性，也没有利用好磁盘IO的预读能力（空间局部性原理），从而带来频繁的IO操作 。</li>
</ol>
<h4 id="多路平衡查找树b-treebalance-tree">多路平衡查找树B-Tree（balance tree）</h4>
<p><img src="en-resource://database/872:1" alt="7bec7f560c97e6f925eaca7126d45a45.png" loading="lazy">@w=500<br>
树的路数取决于关键字的大小。</p>
<ul>
<li>
<p><strong>路数=关键字个数+1</strong></p>
</li>
<li>
<p><strong>关键字个数=磁盘块大小</strong>/（<strong>关键字大小</strong>+冗余空间）<br>
优点：</p>
</li>
<li>
<p>树的深度相对于平衡二叉查找树降低很多，所以查询所需的io操作次数减少。</p>
</li>
<li>
<p>充分利用了磁盘块空间。</p>
</li>
</ul>
<h4 id="加强版的多路平衡查找树btree">加强版的多路平衡查找树B+Tree</h4>
<p><img src="en-resource://database/874:1" alt="8fa8c7ae90b6a096aef430a346e436ed.png" loading="lazy">@w=500<br>
  B+Tree是B-Tree的的升级版，B+Tree使用的是左闭合的关键字节点集合，因为mysql建议使用自增的int型id作为主键。每个节点都不会存储关键字的数据，数据都存储在叶子节点上，所以查询数据都最终落到叶子节点上。B+Tree的叶子节点上的数据是按顺序存储的，每个叶子节点的末尾数据都会指向相邻的下一个叶子节点的起始数据区。<br>
  mysql在表中没有主键时，会使用具有唯一性的字段作为主键存储，如果连唯一性字段都没有，则会创建一个隐式的6位int型主键。</p>
<h5 id="btree与b-tree的区别">B+Tree与B-Tree的区别：</h5>
<ul>
<li>B+节点关键字搜索采用左闭合区间。</li>
<li>B+非叶子节点不保存数据相关信息，只保存关键字和子节点的引用。</li>
<li>B+关键字对应的数据都保存在叶子节点中。</li>
<li>B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系。</li>
</ul>
<h5 id="btree的优点">B+Tree的优点：</h5>
<ul>
<li>B+树是B-树的变种（PLUS版）多路绝对平衡查找树，他拥有B-树的优势</li>
<li>B+树扫库、表能力更强<br>
因为B+树的叶子节点是按顺序排列的，所以扫描叶子节点就可以将整个表数据扫描完成。所以效率更高。</li>
<li>B+树的磁盘读写能力更强<br>
因为B+树的非叶子节点上不存关键字对应的数据，所以每个磁盘块（节点）可以存储的关键字个数越多，所以磁盘的读写能力更强。</li>
<li>B+树的排序能力更强<br>
叶子节点具有顺序性。</li>
<li>B+树的查询效率更加稳定（仁者见仁、智者见智）<br>
  因为B树将关键字和其对应的数据存储在同一个节点上，所以当搜索数据时，因为数据对应的关键字所处节点的深度不同，所以io次数不同，导致查询时间可能差别很大。<br>
  因为B+树将关键字数据都存储在叶子节点上，所以查询任何数据都会落到叶子节点上，所以查询效率更加稳定。<br>
  在程序设计上，程序的可控性要高，程序运行时间要稳定和可知，这样的软件才更加健壮。</li>
</ul>
<h4 id="mysql-btree索引体现形式">Mysql B+Tree索引体现形式</h4>
<h5 id="myisam中btree">MyISAM中B+Tree</h5>
<p><img src="en-resource://database/878:1" alt="d0ae8bab28493c122a45971698ff7c79.png" loading="lazy">@w=500<br>
在myisam引擎中，索引和数据分为两个文件存储。索引的叶子节点存储数据行的存储地址。<br>
<img src="en-resource://database/880:1" alt="89173119419bd66deffcd71046830c87.png" loading="lazy">@w=600<br>
辅助索引和主键索引结构一样。</p>
<h5 id="innodb中btree">InnoDB中B+Tree</h5>
<p><img src="en-resource://database/882:1" alt="92ece67ceb3a4c9d673505b81498776b.png" loading="lazy">@w=500<br>
在InnoDB中索引和数据存储在一个文件中。<br>
<img src="en-resource://database/884:1" alt="9c69dceb9e6395ecf19a462f5b98aec3.png" loading="lazy">@w=500<br>
InnoDB中辅助索引在叶子节点会存储主键索引值，在使用辅助索引时，会先通过辅助索引树查找到主键索引值，然后再通过主键索引树搜索到对应的数据。因此，辅助索引会进行两次树的搜索。</p>
<h5 id="innodb-vs-myisam">InnoDB VS MyISAM</h5>
<p><img src="en-resource://database/886:1" alt="27f60d3580d84d8cf6d6ccadd5fb9cb3.png" loading="lazy">@w=600</p>
<h3 id="索引知识">索引知识</h3>
<h4 id="列的离散性">列的离散性</h4>
<p><img src="en-resource://database/890:1" alt="4c3c9f7da95a5f02d0a49836bf9fba65.png" loading="lazy">@w=300<br>
离散性最好的列：name<br>
count(column)越大离散性越高。<br>
<img src="en-resource://database/892:1" alt="d69a549616f2966c5bc45018291c88f3.png" loading="lazy">@h=100<br>
  因为列的离散性越高，选择性就越好。上图是对sex列建立的索引，可以看出当进行性别查询的时候，可能会存在很多个分支选择，索引的效率会下降，同时mysql查询优化器，会在使用索引查询时判断效率，如果效率过低，还不如走全表扫描查询。<br>
总结：离散性越高，选择性就越好，使用索引查询效率就越高。</p>
<h4 id="最左匹配原则">最左匹配原则</h4>
<p>对索引中关键字进行计算（对比），一定是从左往右依次进行， 且不可跳过。索引中关键字的匹配：对于int型的直接比对数字大小。如果是字符串型的则根据字段建立时的排序规则进行比对，例如使用字母ASCII码进行比对。<br>
<img src="en-resource://database/894:1" alt="b8c5bc1cfd35bf626f5d8b8257787ed9.png" loading="lazy">@w=300</p>
<h4 id="联合索引">联合索引</h4>
<ol>
<li>单列索引<br>
节点中关键字[name]</li>
<li>联合索引<br>
节点中关键字[name,phoneNum]<br>
单列索引是特殊的联合索引</li>
</ol>
<p>联合索引列选择原则：</p>
<ul>
<li>经常用的列优先 【最左匹配原则】</li>
<li>选择性（离散度）高的列优先【离散度高原则】</li>
<li>宽度小的列优先【最少空间原则】</li>
</ul>
<h5 id="李二狗的sql优化">李二狗的sql优化</h5>
<p>经排查发现最常用的sql语句：<br>
Select  *  from users where name = ? ;<br>
Select  *  from users where name = ? and phone_num = ?;<br>
机灵的李二狗的解决方案：<br>
索引一：create index idx_name on users(name);<br>
索引二：create index idx_name_phoneNum on users(name,phone_num);<br>
  查看李二狗创建的索引，可以看到索引二是个联合索引，根据最左匹配原则，索引一这属于冗余索引，所以索引一可以去掉。</p>
<h4 id="覆盖索引">覆盖索引</h4>
<p>  如果查询列可通过索引节点中的关键字直接返回，则该索引称之为覆盖索引。<br>
例如：<br>
create index idx_name_phoneNum on users(name,phone_num);<br>
则语句：<br>
Select  name,phone_num  from users where name = ? and phone_num = ?;<br>
可以直接通过索引关键字返回name和phone_num的值。则idx_name_phoneNum称之为覆盖索引。<br>
  <strong>覆盖索引可减少数据库IO，将随机IO变为顺序IO，可提高查询性能。</strong></p>
<h4 id="总结">总结</h4>
<ol>
<li>索引列数据的长度能少则少。<br>
B+Tree是个多路平衡树，索引列的数据长度越少，树的路数就越多，则树的高度也就越低，每次查询所需的IO次数就越少，能提升查询性能。</li>
<li>索引一定不是越多越好，越全越好，一定是建合适的。</li>
</ol>
<ul>
<li>每个索引都需要单独维护一个索引列数据的存储，过多的建立索引会浪费磁盘空间。</li>
<li>每次进行表中数据的修改、插入或删除操作都需要进行索引重建，建立过多的索引会使修改、插入或删除操作的效率下降。</li>
</ul>
<ol start="3">
<li>匹配列前缀可能用到索引 like 9999%，like %9999%、like %9999用不到索引；<br>
like 9999%也可能存在索引失效的情况，当索引列的数据离散性较低时，使用该索引进行搜索时，会匹配过多的关键字，mysql优化器会放弃索引而进行全表扫描查询。导致索引失效。</li>
<li>where 条件中 not in 和 &lt;&gt;操作无法使用索引； &lt;&gt;表示不等于</li>
<li>匹配范围值，order by 也可用到索引；</li>
<li>多用指定列查询，只返回自己想到的数据列，少用select * ；<br>
使用select * 将不会命中覆盖索引，使用具体字段时可能命中覆盖索引，提升效率。</li>
<li>联合索引中如果不是按照索引最左列开始查找，无法使用索引；<br>
因为索引采用最左匹配原则。<br>
create index idx_name_phoneNum on users(name,phone_num);<br>
如果：<br>
Select  name,phone_num  from users where phone_num = ?;<br>
则不会使用索引。</li>
<li>联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引；</li>
<li>联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引；</li>
</ol>
<h2 id="存储引擎">存储引擎</h2>
<h4 id="存储引擎介绍">存储引擎介绍</h4>
<ol>
<li>插拔式的插件方式。</li>
<li>存储引擎是指定在表之上的，即一个库中的每一个表都可以指定专用的存储引擎。</li>
<li>不管采用什么样的存储引擎，都会在数据区产生对应的一个frm文件（表结构定义描述文件）。</li>
</ol>
<h3 id="csv存储引擎comma-separated-values了解">CSV存储引擎（Comma-Separated Values）了解</h3>
<p>数据存储以CSV文件。<br>
特点：</p>
<ol>
<li>不能定义没有索引、列定义必须为NOT NULL、不能设置自增列<br>
--&gt;不适用大表或者数据的在线处理。</li>
<li>CSV数据的存储用,隔开，可直接编辑CSV文件进行数据的编排<br>
--&gt;数据安全性低<br>
注：编辑之后，要生效使用flush table XXX 命令</li>
</ol>
<p>应用场景：</p>
<ul>
<li>数据的快速导出导入</li>
<li>表格直接转换成CSV</li>
</ul>
<h3 id="archive存储引擎压缩了解">Archive存储引擎（压缩）了解</h3>
<ul>
<li>压缩协议进行数据的存储</li>
<li>数据存储为ARZ文件格式</li>
</ul>
<h4 id="特点">特点：</h4>
<ol>
<li>只支持insert和select两种操作</li>
<li>只允许自增ID列建立索引</li>
<li>行级锁</li>
<li>不支持事务</li>
<li>数据占用磁盘少</li>
</ol>
<h4 id="应用场景">应用场景：</h4>
<p>日志系统，大量的设备数据采集</p>
<h3 id="memory存储引擎-了解">Memory存储引擎  了解</h3>
<p>数据都是存储在内存中，IO效率要比其他引擎高很多，服务重启数据丢失，内存数据表默认只有16M 。</p>
<h4 id="特点-2">特点：</h4>
<p>支持hash索引，B tree索引，默认hash（查找复杂度0(1)）字段长度都是固定长度varchar(32)=char(32) 不支持大数据存储类型字段如 blog，text 表级锁。</p>
<h4 id="应用场景-2">应用场景：</h4>
<p>等值查找热度较高数据 查询结果内存中的计算，大多数都是采用这种存储引擎 作为临时表存储需计算的数据</p>
<h3 id="myisam存储引擎">MyISAM存储引擎</h3>
<p>Mysql5.5版本之前的默认存储引擎，较多的系统表也还是使用这个存储引擎，系统临时表也会用到Myisam存储引擎。</p>
<h4 id="特点-3">特点：</h4>
<ul>
<li>select count(* ) from table 无需进行数据的扫描</li>
<li>数据（MYD）和索引（MYI）分开存储</li>
<li>表级锁</li>
<li>不支持事务</li>
</ul>
<h3 id="innodb-重点">InnoDB  重点</h3>
<p>Mysql5.5及以后版本的默认存储引擎。</p>
<h4 id="特点-4">特点</h4>
<ul>
<li>Its DML operations follow the ACID model  [事务ACID]</li>
<li>Row-level locking[行级锁]</li>
<li>InnoDB tables arrange your data on disk to optimize queries based on primary keys[聚集索引（主键索引）方式进行数据存储]</li>
<li>To maintain data integrity, InnoDB supports FOREIGN KEY constraints[支持外键关系保证数据完整性]</li>
</ul>
<h2 id="mysql体系结构">mysql体系结构</h2>
<p><img src="en-resource://database/888:1" alt="0d9c4adaaee0f8e66d1a7550decc2a56.png" loading="lazy">@w=500</p>
<ul>
<li>Client Connectors<br>
接入方，支持协议很多。</li>
<li>Management Serveices &amp; Utilities<br>
系统管理和控制工具，mysqldump、 mysql复制集群、分区管理等。</li>
<li>Connection Pool<br>
连接池：管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求。</li>
<li>SQL Interface SQL<br>
接口：接受用户的SQL命令，并且返回用户需要查询的结果。</li>
<li>Parser<br>
解析器，SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的。</li>
<li>Optimizer<br>
查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。</li>
<li>Cache和Buffer<br>
高速缓存区） 查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</li>
<li>pluggable storage Engines<br>
插件式存储引擎。存储引擎是MySql中具体的与文件打交道的子系统。</li>
<li>file system<br>
文件系统，数据、日志（redo，undo）、索引、错误日志、查询记录、慢查询等。</li>
</ul>
<h3 id="mysql查询优化详解">mysql查询优化详解</h3>
<h4 id="mysql查询执行路径">mysql查询执行路径</h4>
<p><img src="en-resource://database/896:1" alt="6930827b1a3d52a38547b487a8801ada.png" loading="lazy">@h=300<br>
上图执行路径可以分为以下五条：</p>
<ol>
<li>mysql 客户端/服务端通信</li>
<li>查询缓存</li>
<li>查询优化处理</li>
<li>查询执行引擎</li>
<li>返回客户端</li>
</ol>
<h5 id="mysql-客户端服务端通信">mysql 客户端/服务端通信</h5>
<p>mysql客户端和服务端间得通信方式是：<strong>半双工</strong><br>
全双工：双向通信，发送同时也可以接收</p>
<p>半双工：双向通信，同时只能接收或者是发送，无法同时做操作</p>
<p>单工：只能单一方向传送</p>
<p>半双工通信：在任何一个时刻，要么是有服务器向客户端发送数据，要么是客户端向服务端发送数据，这两个动作不能同时发生。所以我们无法也无需将一个消息切成小块进行传输<br>
半双工特点和限制： 客户端一旦开始发送消息，另一端要接收完整个消息才能响应。 客户端一旦开始接收数据没法停下来发送指令。</p>
<h6 id="mysql-客户端服务端通信状态查询">mysql 客户端/服务端通信状态查询</h6>
<p>对于一个mysql连接，或者说一个线程，时刻都有一个状态来标识这个连接正在做什么。<br>
查看命令 show full processlist / show processlist<br>
https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html  (状态全集)</p>
<ul>
<li>Sleep 线程正在等待客户端发送数据</li>
<li>Query 连接线程正在执行查询</li>
<li>Locked 线程正在等待表锁的释放</li>
<li>Sorting result 线程正在对结果进行排序</li>
<li>Sending data 向请求端返回数据</li>
</ul>
<h5 id="查询缓存">查询缓存</h5>
<ul>
<li>工作原理：<br>
缓存SELECT操作的结果集和SQL语句；<br>
新的SELECT语句，先去查询缓存，判断是否存在可用的记录集；</li>
<li>判断标准：<br>
与缓存的SQL语句，是否完全一样，区分大小写 (简单认为存储了一个key-value结构，key为sql，value为sql查询结果集)</li>
<li>缓存属性设置</li>
</ul>
<ol>
<li>query_cache_type 值：0 -– 不启用查询缓存，默认值； 值：1 -– 启用查询缓存，只要符合查询缓存的要求，客户端的查询语句和记录集 都可以缓存起来，供其他客户端使用，加上 SQL_NO_CACHE将不缓存 值：2 -– 启用查询缓存，只要查询语句中添加了参数：</li>
<li>SQL_CACHE，且符合查询 缓存的要求，客户端的查询语句和记录集，则可以缓存起来，供其他客户端使用</li>
<li>query_cache_size 允许设置query_cache_size的值最小为40K，默认1M，推荐设置 为：64M/128M；</li>
<li>query_cache_limit 限制查询缓存区最大能缓存的查询记录集，默认设置为1M</li>
<li>show status like 'Qcache%' 命令可查看缓存情况</li>
</ol>
<ul>
<li>查询缓存不会缓存得情况<br>
1.当查询语句中有一些不确定的数据时，则不会被缓存。如包含函数NOW()， CURRENT_DATE()等类似的函数，或者用户自定义的函数，存储函数，用户变量等都不会被缓存。<br>
2.当查询的结果大于query_cache_limit设置的值时，结果不会被缓存。<br>
3.对于InnoDB引擎来说，当一个语句在事务中修改了某个表，那么在这个事务提交之前，所有与这个表相关的查询都无法被缓存。因此长时间执行事务，会大大降低缓存命中率。<br>
4.查询的表是系统表。<br>
5.查询语句不涉及到表。</li>
<li>查询缓存的弊端<br>
为什么mysql默认关闭了缓存开启？？<br>
1.在查询之前必须先检查是否命中缓存,浪费计算资源。<br>
2.如果这个查询可以被缓存，那么执行完成后，MySQL发现查询缓存中没有这 个查询，则会将结果存入查询缓存，这会带来额外的系统消耗。<br>
3.针对表进行写入或更新数据时，将对应表的所有缓存都设置失效。<br>
4.如果查询缓存很大或者碎片很多时，这个操作可能带来很大的系统消耗。</li>
<li>查询缓存适合业务场景<br>
以读为主的业务，数据生成之后就不常改变的业务，比如门户类、新闻类、报表类、论坛类等。</li>
</ul>
<h5 id="查询优化处理">查询优化处理</h5>
<p>查询优化处理的三个阶段：</p>
<ol>
<li><strong>解析sql</strong><br>
通过lex词法分析,yacc语法分析将sql语句解析成解析树 https://www.ibm.com/developerworks/cn/linux/sdk/lex/</li>
<li><strong>预处理阶段</strong><br>
根据mysql的语法的规则进一步检查解析树的合法性，如：检查数据的表 和列是否存在，解析名字和别名的设置。还会进行权限的验证</li>
<li><strong>查询优化器（重点）</strong><br>
优化器的主要作用就是找到最优的执行计划</li>
</ol>
<h5 id="查询优化器如何找到最优执行计划">查询优化器如何找到最优执行计划？</h5>
<ul>
<li><strong>使用等价变换规则</strong><br>
例如：5=5 and a&gt;5 改写成 a&gt;5<br>
a&lt;b and a=5 改写成 b&gt;5 and a=5</li>
<li><strong>优化count 、min、max等函数</strong><br>
min函数只需找索引最左边<br>
max函数只需找索引最右边<br>
myisam引擎count( * )有单独存储，可以直接查询。</li>
<li><strong>覆盖索引扫描</strong></li>
<li><strong>子查询优化</strong><br>
*** 提前终止查询**<br>
用了limit关键字或者使用不存在的条件</li>
<li><strong>IN的优化</strong><br>
先对条件进行排序，然后使用二分查找</li>
</ul>
<p><strong>Mysql的查询优化器是基于成本计算的原则。他会尝试各种执行计划。 数据抽样的方式进行试验（随机的读取一个4K的数据块进行分析）</strong></p>
<h5 id="mysql查询优化-执行计划">mysql查询优化-执行计划</h5>
<figure data-type="image" tabindex="1"><img src="en-resource://database/898:1" alt="1fbe81391cfd3eff001e9ad1e391d50e.png" loading="lazy"></figure>
<h6 id="执行计划-id">执行计划-id</h6>
<p><strong>select查询的序列号，标识执行的顺序</strong></p>
<ol>
<li>id相同，执行顺序由上至下。</li>
<li>id不同，id大的先执行。（子查询的id会增大）</li>
<li>id存在相同的和不同的：id相同的为一组，执行顺序同1、2。</li>
</ol>
<h6 id="执行计划-select_type">执行计划-select_type</h6>
<p><strong>查询的类型，主要是用于区分普通查询、联合查询、子查询等</strong></p>
<ul>
<li>SIMPLE：简单的select查询，查询语句中不包括子查询或者union。</li>
<li>PRIMARY：查询中包含子查询，最外层查询标记为PRIMARY。</li>
<li>SUBQUERY/MATERIALIZED<br>
SUBQUERY：SUBQUERY表示在select 或 where列表中包含了子查询；<br>
MATERIALIZED：表示where 后面in条件的子查询；</li>
<li>UNION：若第二个select出现在union之后，则被标记为union；</li>
<li>UNION RESULT：从union表获取结果的select；</li>
</ul>
<h6 id="执行计划-table">执行计划-table</h6>
<p><strong>查询涉及到的表</strong></p>
<ul>
<li>直接显示表名或者表的别名;</li>
<li>&lt;unionM,N&gt; 由ID为M,N 查询union产生的结果;</li>
<li><subqueryN> 由ID为N查询生产的结果;</li>
</ul>
<h6 id="执行计划-type">执行计划-type</h6>
<p><strong>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：<br>
system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p>
<ul>
<li>system：表只有一行记录（等于系统表），const类型的特例，基本不会出现，可以忽略不计；</li>
<li>const：表示通过索引一次就找到了，const用于primary key或unique索引；</li>
<li>eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或 唯一索引扫描；</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质是也是一种索引访问；</li>
<li>range：只检索给定范围的行，使用一个索引来选择行；</li>
<li>index:Full Index Scan，索引全表扫描，把索引从头到尾扫一遍；</li>
<li>all：Full Table Scan，遍历全表以找到匹配的行；</li>
</ul>
<h6 id="执行计划其它属性">执行计划其它属性</h6>
<ul>
<li>possible_keys<br>
查询中可能用到的索引；</li>
<li>key<br>
实际使用的索引，如果为null，则没有使用索引；</li>
<li>rows<br>
根据表统计信息或者索引选用情况，大致估算出找到所需的记录所需要读取的行数；</li>
<li>filtered<br>
它指返回结果的行占需要读到的行(rows列的值)的百分比，表示返回结果的行数占需读取行数的百分比，filtered的值越大越好；</li>
</ul>
<h6 id="执行计划-extra">执行计划-Extra</h6>
<p>十分重要的额外信息<br>
1、<strong>Using filesort</strong>：<br>
mysql对数据使用一个外部的文件内容进行了排序，而不是按照表内的索引进行排序读取；<br>
2、<strong>Using temporary</strong>：<br>
使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 或 group by；<br>
3、<strong>Using index</strong>：<br>
表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高；<br>
4、<strong>Using where</strong>：<br>
使用了where过滤条件；<br>
5、<strong>select tables optimized away</strong>：<br>
基于索引优化MIN/MAX操作或者MyISAM存储引擎优化COUNT( * )操作，不必等到执行阶段在进行计算，查询执行 计划生成的阶段即可完成优化；</p>
<h5 id="执行引擎执行">执行引擎执行</h5>
<p>调用插件式的存储引擎的原子API的功能进行执行计划的执行。</p>
<h5 id="返回客户端">返回客户端</h5>
<p>1、有需要做缓存的，执行缓存操作。<br>
2、增量的返回结果：开始生成第一条结果时,mysql就开始往请求方逐步返回数据 好处： mysql服务器无须保存过多的数据，不会浪费内存。用户体验好，马上就拿到了数据。</p>
<h4 id="定位慢sql">定位慢sql</h4>
<ol>
<li>业务驱动</li>
<li>测试驱动</li>
<li>慢查询日志</li>
</ol>
<h5 id="慢查询日志配置">慢查询日志配置</h5>
<p>show variables  like 'slow_query_log'<br>
set global slow_query_log = on<br>
set global slow_query_log_file = '/var/lib/mysql/gupaoedu-slow.log'<br>
set global log_queries_not_using_indexes = on<br>
set global long_query_time  = 0.1  (秒)</p>
<h5 id="慢查询日志分析">慢查询日志分析</h5>
<p><img src="en-resource://database/900:1" alt="cd6465616357a1f081d164b1e93eac16.png" loading="lazy"><br>
Time ：日志记录的时间<br>
User@Host：执行的用户及主机<br>
Query_time：查询耗费时间  Lock_time 锁表时间  Rows_sent 发送给请求方的记录 条数  Rows_examined 语句扫描的记录条数<br>
SET timestamp  语句执行的时间点<br>
select ....             执行的具体语句</p>
<p>分析工具：<br>
mysqldumpslow -t 10 -s at /var/lib/mysql/gupaoedu-slow.log</p>
<h2 id="事务">事务</h2>
<h3 id="什么是事务">什么是事务</h3>
<p>数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作； 事务是一组不可再分割的操作集合（工作逻辑单元）;<br>
<strong>典型事务场景(转账)：</strong><br>
update user_account set balance = balance - 1000 where userID = 3;<br>
update user_account set balance = balance +1000 where userID = 1;<br>
<strong>mysql中如何开启事务</strong>：<br>
begin / start transaction       -- 手工<br>
commit / rollback                  -- 事务提交或回滚<br>
set session autocommit = on/off; -- 设定事务是否自动开启<br>
<strong>JDBC 编程：</strong><br>
connection.setAutoCommit（boolean）;<br>
<strong>Spring 事务AOP编程：</strong><br>
expression=execution(com.gpedu.dao.* . * (..))</p>
<h3 id="事务acid特性">事务ACID特性</h3>
<p><strong>原子性（Atomicity）</strong><br>
一个事务时最小的工作单元，不可分割。事务内的操作要么全部成功提交，要么全部失败回滚。<br>
<strong>一致性（Consistency）</strong><br>
事务操作数据的结果要具有一致性，数据的新增或删除要和预期结果一致。<br>
<strong>隔离性（Isolation）</strong><br>
事务之间对事务内部的操作是不可见的，事务是个独立的单元。<br>
<strong>持久性（Durability）</strong><br>
事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失。</p>
<h3 id="事务并发带来的问题">事务并发带来的问题</h3>
<h4 id="脏读读未提交">脏读——读未提交</h4>
<p><img src="en-resource://database/902:1" alt="b0b4a4c47fe4f602870cf212b6482e5b.png" loading="lazy"><br>
事务A会读到另一个事务B未提交的数据，叫做脏读。</p>
<h4 id="不可重复读读已提交">不可重复读——读已提交</h4>
<p><img src="en-resource://database/904:1" alt="970c0d26637d04c4bd59e1bf20b3d568.png" loading="lazy"><br>
事务A中多次读取多行数据时,事务B对这行数据进行了修改，导致事务A多次读取结恶不一样，这条数据出现不可重复读的问题。</p>
<h4 id="幻读">幻读</h4>
<p><img src="en-resource://database/906:1" alt="539e50212c14b57cc63aae135f43b1b7.png" loading="lazy"><br>
事务A在进行范围查询的时候，事务B对查询范围内的数据进行了新增或者修改，导致事务A两次查询结果条数不一样，这种现象叫做幻读。</p>
<h3 id="事务四种隔离级别">事务四种隔离级别</h3>
<h4 id="read-uncommit-读未提交">Read Uncommit (读未提交)</h4>
<p>事务并发的问题全部不能解决。隔离级别最低。</p>
<h4 id="read-commit读已提交">Read Commit（读已提交）</h4>
<p>可以解决脏读问题。</p>
<h4 id="repeatable-read-可重复读">Repeatable Read (可重复读)</h4>
<p>可以解决不可重复读的问题，但是并不能解决幻读问题。</p>
<h4 id="serializable串行化">Serializable（串行化）</h4>
<p>所有事务并发问题都能解决。隔离级别最高。</p>
<h3 id="innodb对四种隔离级别的支持程度">InnoDB对四种隔离级别的支持程度</h3>
<figure data-type="image" tabindex="2"><img src="en-resource://database/908:1" alt="266ad919d0369d2f78050b7f5c3c6f21.png" loading="lazy"></figure>
<h2 id="锁">锁</h2>
<h3 id="理解表锁和行锁">理解表锁和行锁</h3>
<p>锁是用于管理不同事务对共享资源的并发访问。<br>
<strong>表锁与行锁的区别：</strong><br>
锁定粒度：表锁&gt;行锁<br>
加锁效率：表锁&gt;行锁<br>
冲突概率：表锁&gt;行锁<br>
并发性能：表锁&lt;行锁<br>
InnoDB存储引擎支持行锁和表锁（另类的行锁）,InnoDB的表锁是通过给每行数据加锁实现。</p>
<h3 id="mysql-innodb锁类型">mysql InnoDB锁类型</h3>
<ul>
<li>共享锁（行锁）：Shared Locks</li>
<li>排它锁（行锁）：Exclusive Locks</li>
<li>意向锁共享锁（表锁）：Intention Shared Locks</li>
<li>意向锁排它锁（表锁）：Intention Exclusive Locks</li>
<li>自增锁：AUTO-INC Locks</li>
</ul>
<h4 id="共享锁和排它锁">共享锁和排它锁</h4>
<p><strong>共享锁:</strong> 又称为读锁，简称S锁。共享锁就是多个事务对于同一个数据可以共享一把锁，都能访问数据，但是只能读不能修改。<br>
加锁释锁方式：<br>
select * from user where id = 1 LOCK IN SHARE MODE;<br>
commit/rollback<br>
<strong>排他锁:</strong><br>
又称为写锁，简称X锁，排他锁不能与其他锁并存，如一个事务获取了一个数据行的排他 锁，其他事务就不能再获取该行的锁（共享锁、排他锁），只有该获取了排他锁的事务是可以对 数据行进行读取和修改，（其他事务要读取数据可来自于快照）<br>
加锁释锁方式：<br>
delete / update / insert 默认加上X锁<br>
SELECT * FROM table_name WHERE ... FOR UPDATE<br>
commit/rollback</p>
<h4 id="innodb行锁到底锁了什么">InnoDB行锁到底锁了什么？</h4>
<p><strong>InnoDB是通过给索引上的索引项加锁实现的。</strong></p>
<p><strong>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</strong></p>
<p><strong>表锁：lock tables xx read/write；</strong></p>
<h4 id="意向锁共享锁is和意向锁排它锁ix">意向锁共享锁（IS）和意向锁排它锁（IX）</h4>
<p><strong>意向共享锁(IS)</strong><br>
表示事务准备给数据行加入共享锁，即一个数据行加共享锁前必须先取得该表的IS锁， 意向共享锁之间是可以相互兼容的。<br>
<strong>意向排它锁(IX)</strong><br>
表示事务准备给数据行加入排他锁，即一个数据行加排他锁前必须先取得该表的IX锁， 意向排它锁之间是可以相互兼容的。</p>
<p>意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预<br>
意义：<br>
当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</p>
<h4 id="自增锁">自增锁</h4>
<p>针对自增列自增长的一个特殊的表级别锁<br>
show variables like  'innodb_autoinc_lock_mode';<br>
默认取值1，代表连续，事务未提交ID永久丢失</p>
<h4 id="临键锁next-key间隙锁gap记录锁recoed">临键锁（Next-key）&amp;间隙锁（Gap）&amp;记录锁（Recoed）</h4>
<p><strong>临键锁：</strong><br>
<strong>锁住记录+区间（左开右闭）</strong><br>
当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数据命中则此时SQL语句加上的锁为Next-key locks，锁住索引的记录+区间（左开右闭）<br>
<strong>间隙锁：</strong><br>
<strong>锁住数据不存在的区间（左开右开）</strong><br>
当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，锁住索引不存在的区间（左开右开）<br>
<strong>记录锁：</strong><br>
<strong>锁住具体的索引项</strong><br>
当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，锁住具体的索引项。</p>
<h5 id="临键锁">临键锁</h5>
<p><img src="en-resource://database/910:1" alt="9116eeb61557a3780c864d3cb3facda2.png" loading="lazy"><br>
为什么InnoDB使用临键锁作为行锁的默认算法？<br>
临键锁可以解决再RR（可重复读）事务下的幻读问题。</p>
<h5 id="间隙锁">间隙锁</h5>
<p><img src="en-resource://database/912:1" alt="40e92ce14d6359d172771ca41f39a66a.png" loading="lazy"><br>
Gap只在RR事务隔离级别存在</p>
<h5 id="记录锁">记录锁</h5>
<figure data-type="image" tabindex="3"><img src="en-resource://database/914:1" alt="b508ede1bd73997eba392ed5d6bc1bed.png" loading="lazy"></figure>
<h4 id="利用锁怎么解决事务问题">利用锁怎么解决事务问题？</h4>
<p>解决脏读：<br>
<img src="en-resource://database/916:1" alt="2c857f6c6c474f2a9e88a02cf8aee727.png" loading="lazy"><br>
解决不可重复读：<br>
<img src="en-resource://database/918:1" alt="8a836c7315a8512463cab26bdef1eeee.png" loading="lazy"><br>
解决幻读：<br>
<img src="en-resource://database/920:1" alt="f3d5a0d144239bd89b3a6d9eff5dbe5a.png" loading="lazy"></p>
<h4 id="死锁介绍">死锁介绍</h4>
<p>多个并发事务，每个事务都持有锁，并且每个事务都需要再次获得锁，当两个或多个事务都持有对方需要再次获得的锁的时候就会产生死锁。</p>
<h4 id="死锁的避免">死锁的避免</h4>
<ol>
<li>类似的业务逻辑按固定的顺序访问表和行。</li>
<li>将大事务拆分为小事务。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。</li>
<li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择。</li>
<li>为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁（或者说是表锁）</li>
</ol>
<h3 id="mvcc是什么">MVCC是什么？</h3>
<p><strong>MVCC： Multiversion concurrency control  (多版本并发控制)</strong><br>
普通话解释：<br>
并发访问(读或写)数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的堵塞，从而引发读操作的并发问题。</p>
<p>mysql在数据行后面会追加DB_TRX_ID（数据行的版本号）和DB_ROLL_PT（删除版本号）两个字段。这两个字段对数据进行版本控制。</p>
<h3 id="undo-log">Undo log</h3>
<p><img src="en-resource://database/922:1" alt="52f1e59c306cf914323c17c82cf38e92.png" loading="lazy"><br>
<strong>Undo log是什么：</strong><br>
undo意为撤销的意思，即为RollBack操作。<br>
undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log)。</p>
<p><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></p>
<p><strong>Undo Log实现事务原子性：</strong><br>
事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
<p><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></p>
<p><strong>Undo log实现多版本并发控制：</strong><br>
事务未提交之前，Undo保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。</p>
<h4 id="当前读和快照读">当前读和快照读</h4>
<p><strong>快照读：</strong><br>
SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读。<br>
innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成<br>
<strong>当前读：</strong><br>
SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改<br>
UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读。</p>
<h3 id="redo-log">Redo log</h3>
<p><img src="en-resource://database/924:1" alt="de82ded7bb040be9cbd5094360985dd8.png" loading="lazy"><br>
Redo log是顺序io，较直接持久化的随机io要快。<br>
<strong>Redo log是什么：</strong><br>
redo意为重做的意思，是对已经commit数据的恢复操作。<br>
Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)。<br>
<strong>Redo log的持久：</strong><br>
不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体的落盘策略可以进行配置。</p>
<p><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></p>
<p><strong>Redo Log实现事务持久性：</strong><br>
防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</p>
<p><strong>Redo log知识点：</strong></p>
<ol>
<li>指定Redo log 记录在{datadir}/ib_logfile1&amp;ib_logfile2 可通过innodb_log_group_home_dir 配置指定目录存。</li>
<li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所以Redo log的写入是日志文件循环写入的。</li>
</ol>
<ul>
<li>指定Redo log日志文件组中的数量 innodb_log_files_in_group 默认为2</li>
<li>指定Redo log每一个日志文件最大存储量innodb_log_file_size  默认48M</li>
<li>指定Redo log在cache/buffer中的buffer池大小innodb_log_buffer_size 默认16M</li>
</ul>
<ol start="3">
<li>Redo buffer 持久化Redo log的策略， Innodb_flush_log_at_trx_commit：</li>
</ol>
<ul>
<li>取值 0<br>
每秒提交 Redo buffer  --&gt;  Redo log  OS cache --&gt;flush cache to disk[可能丢失一秒内的事务数据]</li>
<li>取值 1<br>
默认值，每次事务提交执行Redo buffer  --&gt;  Redo log  OS cache --&gt;flush cache to disk [最安全，性能最差的方式]</li>
<li>取值 2<br>
每次事务提交执行Redo buffer  --&gt;  Redo log  OS cache  再每一秒执行 -&gt;flush cache to disk操作</li>
</ul>
<h2 id="配置优化">配置优化</h2>
<h3 id="mysql服务器参数">mysql服务器参数</h3>
<p>基于参数的作用域：</p>
<ol>
<li>全局参数<br>
set global autocommit = ON/OFF;</li>
<li>会话参数(会话参数不单独设置则会采用全局参数)<br>
set session autocommit = ON/OFF;<br>
注意：<br>
全局参数的设定对于已经存在的会话无法生效 会话参数的设定随着会话的销毁而失效 全局类的统一配置建议配置在默认配置文件中，否则重启服务会导致配置失效。</li>
</ol>
<p><strong>寻找配置文件方法：</strong><br>
mysql --help  寻找配置文件的位置和加载顺序<br>
Default options are read from the following files in the given order: /etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf<br>
mysql --help | grep -A 1 'Default options are read from the following files in the given order'</p>
<h4 id="全局文件配置">全局文件配置</h4>
<p>最大连接数配置 max_connections<br>
系统句柄数配置 /etc/security/limits.conf ulimit -a<br>
mysql句柄数配置 /usr/lib/systemd/system/mysqld.service<br>
<strong>最大连接数配置计算：</strong><br>
<strong>sort_buffer_size</strong><br>
connection排序缓冲区大小 建议256K(默认值)-&gt; 2M之内<br>
当查询语句中有需要文件排序功能时，马上为connection分配配置的内存大小。 <strong>join_buffer_size</strong><br>
connection关联查询缓冲区大小 建议256K(默认值)-&gt; 1M之内<br>
当查询语句中有关联查询时，马上分配配置大小的内存用这个关联查 询，所以有可能在一个查询语句中会分配很多个关联查询缓冲区。<br>
<strong>上述配置4000连接占用内存：</strong> 4000*(0.256M+0.256M) = 2G</p>
<p><strong>Innodb_buffer_pool_size</strong> 重点：<br>
图中的缓冲区，并不只是查询缓存。<br>
innodb buffer/cache的大小（默认128M）<br>
<strong>Innodb_buffer_pool</strong><br>
数据缓存 索引缓存 缓冲数据 内部结构<br>
大的缓冲池可以减小多次磁盘I/O访问相同的表数据以提高性能<br>
<strong>参考计算公式：</strong><br>
Innodb_buffer_pool_size = （总物理内存 - 系统运行所用 - connection 所用）* 90%</p>
<p><strong>https://www.cnblogs.com/wyy123/p/6092976.html   常见配置的帖子</strong></p>
<h3 id="数据库表设计">数据库表设计</h3>
<p><strong>第一范式（ 1NF）：</strong><br>
字段具有原子性,不可再分。 所有关系型数据库系统都满足第一范式）数据库表中的字 段都是单一属性的， 不可再分；<br>
<strong>第二范式（ 2NF）：</strong><br>
要求实体的属性完全依赖于主键。 所谓完全依赖是指不能存在仅依赖主键一部分的属性， 如果存在， 那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体， 新实体与原 实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。 简而言之， 第二范式就是属性完全依赖主键。<br>
<strong>第三范式（ 3NF）：</strong><br>
满足第三范式（ 3NF） 必须先满足第二范式（ 2NF）。 简而言之， 第三范式（ 3NF） 要求一个数据库表中不包含已在其它表中已包含的非主键信息。<br>
<strong>简单一点：<br>
1， 每一列只有一个单一的值，不可再拆分<br>
2， 每一行都有主键能进行区分<br>
3， 每一个表都不包含其他表已经包含的非主键信息。</strong></p>
<p><strong>充分的满足第一范式设计将为表建立太量的列</strong><br>
数据从磁盘到缓冲区，缓冲区脏页到磁盘进行持久的过程中，列的数量过多会导致性能下降。过多的列影响转换和持久的性能<br>
<strong>过分的满足第三范式化造成了太多的表关联</strong><br>
表的关联操作将带来额外的内存和性能开销<br>
<strong>使用innodb引擎的外键关系进行数据的完整性保证</strong><br>
外键表中数据的修改会导致Innodb引擎对外键约束进行检查，就带来了额外的开销</p>
<h3 id="日志">日志</h3>
<p>bin_log是主从复制<br>
undo_log是事务回滚<br>
redo_log是崩溃恢复</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[servlet解析]]></title>
        <id>https://hiwei-zhang.github.io/post/servlet-jie-xi/</id>
        <link href="https://hiwei-zhang.github.io/post/servlet-jie-xi/">
        </link>
        <updated>2017-01-06T13:54:37.000Z</updated>
        <summary type="html"><![CDATA[<p>servlet相关知识点</p>
]]></summary>
        <content type="html"><![CDATA[<p>servlet相关知识点</p>
<!-- more -->
<h4 id="servlet特征">servlet特征</h4>
<ol>
<li>servlet是单例多线程的。</li>
<li>一个servlet实例只会执行一次无参构造器与init()方法，并且是在第一次访问时执行。</li>
<li>用户每提交一次对当前servlet的请求，就会执行一次service()方法。</li>
<li>一个servlet实例只会执行一次destroy()方法，在应用停止时执行。</li>
<li>由于servlet是单例多线程的，所以为了保证其线程安全性，一般情况下是不为servlet类定义可修改的成员变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。</li>
<li>默认情况下，servlet在web容器启动时是不会被实例化的。</li>
</ol>
<h4 id="由genericservlet看java的多态">由GenericServlet看java的多态</h4>
<p>  java程序的运行分为编译器和运行期。运行期的类型绑定称之为动态绑定。<br>
  在GenericServlet中实现了init(ServletConfig config)方法：</p>
<pre><code>@Override
public void init(ServletConfig config) throws ServletException {    
    this.config = config;    
    this.init();
}
</code></pre>
<p>但是GenericServlet的子类也可能需要实现init(ServletConfig config)方法，在子类实现该方法的时候如果未调用super.init(config)方法，则会导致ServletConfig初始化失败。<br>
所以GenericServlet添加了重载方法init()交给子类实现。</p>
<pre><code>public void init() throws ServletException {   
    // NOOP by default
   }
</code></pre>
<p>子类只需要实现init()方法，只需要关注自身业务实现即可。实现了代码的解耦。这里所用到的就是java的多态。</p>
]]></content>
    </entry>
</feed>